 lang -> expr* | DESCRIBE*
 expr -> EXPR_IF_ELSE | EXPR_WHILE | EXPR_FOR | EXPR_ASSIGN | DEF_CALL | OBJ_CALL | OBJ_ASSIGN
 EXPR_ASSIGN -> VAR ASSIGN_OP VALUE (OP VALUE)*
 VALUE -> VAR | DIGIT | STRING | DEF_CALL | OBJ_CALL
 DESCRIBE -> DESCR_DEF | DESCR_CLASS
 OBJ_ASSIGN ->

 EXPR_WHILE -> WHILE L_BRACKET EXPR_PREDICATE R_BRACKET EXEC_BLOCK END
 EXPR_PREDICATE -> BOOL | VALUE | (VALUE CONDITIONAL_OP VALUE)
 VALUE -> VAR | DIGIT | STRING | DEF_CALL
 EXEC_BLOCK -> expr ((CONTINUE | BRAKE) expr)*

 while (a < b)
     a = a + 1
 end

 EXPR_IF_ELSE -> if L_BRACKET EXPR_PREDICATE R_BRACKET EXEC_BLOCK EXPR_ELIF* | EXPR_ELSE{1,0} END
 EXPR_PREDICATE -> BOOL | EXPR_DEF | (VALUE CONDITIONAL_OP VALUE)
 EXEC_BLOCK -> expr

 EXPR_ELIF -> L_BRACKET EXPR_PREDICATE R_BRACKET EXEC_BLOCK EXPR_ELIF* EXPR_ELSE+ END
 EXEC_BLOCK -> expr

 EXPR_ELSE -> ELSE EXEC_BLOCK END

if (a == b)
    a = 0
elif (a < b)
    a = b
else
	b = 0
end



 EXPR_FOR -> FOR FOR_BLOCK EXEC_BLOCK END
 FOR_BLOCK -> L_BRACKET FOR_B_P1 FOR_B_P2 FOR_B_P3 R_BRACKET
 FOR_B_P1 -> EXPR_ASSIGN (ENUM_SEPARATE EXPR_ASSIGN)* SEMICOLON
 FOR_B_P2 -> EXPR_PREDICATE SEMICOLON
 FOR_B_P3 -> EXPR_ASSIGN (ENUM_SEPARATE EXPR_ASSIGN)* SEMICOLON

 DESCR_DEF -> DEF VAR L_BRACKET (VAR (ENUM_SEPARATE VAR)*)? R_BRACKET EXEC_BLOCK END
 EXEC_BLOCK -> expr

 DEF_CALL -> VAR L_BRACKET (VAR (ENUM_SEPARATE VAR)*)? R_BRACKET EXEC_BLOCK END
 EXEC_BLOCK -> expr


 (gos_)(NAME_STRUCT)<TYPE> VAR
 NAME_STRUCT -> *список реализованных структур*
 TYPE -> *список описанных/существующих данных*

 gos_list<int> mylist
 mylist.add(1)
 mylist.get(0)